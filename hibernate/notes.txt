Two types of access

Field based and property based

Annotations can be applied on field or getters
Default is field based

If @Id is present on field then entire class is field based else its property based

It can be explicitly mentioned using @Access(AccessType.FIELD)

for property mention AccessType.PROPERTY
still we can assign FIELD to select variables

ex:

@Acess(AccessType.FIELD)
class Passenger {
@Id
private int id

@Access(AccessType.PROPERTY)
public String getName() {
    return name;
}
}

field based: easy to read, no need to expose getters

primary key:
simple or composite

rule for composite
public, no args constr, serializable, override equals and hashcode


genratedvalue is only for simple primary key
can be applied to field or property

good to specify fetch type as lazy for -to-one relations

dont use CascadeType.REMOVE or ALL

Prefer using Set instead of List for many to many relationship

Use @Fetch(FetchMode.SUBSELECT) to preven n+1 queries problem
lets say we have 5 passengers and each passenger has 5 tickets.
when we fetch the passengers, it will execute 6 queries
1 query to fetch all passengers and 5 queries to get tickets for each passengers
if we use above annotation then it uses only 2 queries

If we want to fetch all passengers and their tickets in just one query
then use join fetch on custom query in interface

@Query("select distinct p from passengers p join fetch p.tickets")
List<Passengers> findAll();


Relations

uni and bidirectional

Many part is always the owning side
owning side drive the updates

@OneToMany, ManyToOne, OneToOne, ManyToMany

@JonTable, cross reference table for mapping relationship
its on the owning side of the relationship and receives parameters


JoinColumn

specifies column for joining an entity
takes a name parameter and referencedColumnName parameter


JoinColumns

mapping for composite foreign keys
groups @JoinColumn annotation


Embeddable classes

Fine grained classes representing the entity state
dont have persistent identiy of their own
cannot be shared across persistent entities
exist only as part of the state of entity to which they belong
must be annotated as @Embeddable
can be customized using @AttributeOverride or @AttributeOverrides
in the main class add @Embedded for the field where above class has to be embedded

@ElementCollection
@CollectionTable

key and value can be either basic or embeddable class
@MapKeyColumn
@Column - specifies the column

